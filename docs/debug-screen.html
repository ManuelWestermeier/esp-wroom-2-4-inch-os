<!-- esp32-screen-viewer.html (updated) -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>ESP32 Screen Viewer</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          sans-serif;
        padding: 12px;
      }
      #canvas {
        image-rendering: pixelated;
        width: 640px;
        height: 480px;
        border: 1px solid #222;
        touch-action: none;
      }
      button {
        margin-right: 6px;
      }
      #status {
        margin-left: 8px;
        color: #555;
      }
    </style>
  </head>
  <body>
    <div>
      <button id="connectBtn">Connect</button>
      <button id="getFrameBtn" disabled>Get Frame</button>
      <span id="status">Disconnected</span>
    </div>
    <canvas id="canvas" width="320" height="240"></canvas>

    <script>
      (async () => {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const connectBtn = document.getElementById("connectBtn");
        const getFrameBtn = document.getElementById("getFrameBtn");
        const statusText = document.getElementById("status");

        const W = canvas.width,
          H = canvas.height;
        const frameBuf = new Uint16Array(W * H);
        const imageData = ctx.createImageData(W, H);

        let port = null;
        let writer = null;
        let reader = null;

        const CMD_GET_FRAME = 0x01;

        function updateCanvas() {
          for (let i = 0; i < W * H; i++) {
            const v = frameBuf[i];

            // Extract RGB565 components
            // Red is 5 bits, Green is 6 bits, Blue is 5 bits
            const r5 = (v >> 11) & 0x1f;
            const g6 = (v >> 5) & 0x3f;
            const b5 = v & 0x1f;

            // Bit Replication:
            // Instead of just shifting (r5 << 3), we fill the bottom bits
            // with the top bits of the same color for a full 0-255 range.
            imageData.data[i * 4] = (r5 << 3) | (r5 >> 2); // Red (8-bit)
            imageData.data[i * 4 + 1] = (g6 << 2) | (g6 >> 4); // Green (8-bit)
            imageData.data[i * 4 + 2] = (b5 << 3) | (b5 >> 2); // Blue (8-bit)
            imageData.data[i * 4 + 3] = 255; // Alpha (Opaque)
          }
          ctx.putImageData(imageData, 0, 0);
        }

        async function readLoop(readerStream) {
          let buf = new Uint8Array(0);
          while (true) {
            const { value, done } = await readerStream.read();
            if (done) break;
            if (!value) continue;

            const newBuf = new Uint8Array(buf.length + value.length);
            newBuf.set(buf, 0);
            newBuf.set(value, buf.length);
            buf = newBuf;

            let offset = 0;
            while (offset + 6 <= buf.length) {
              if (buf[offset] !== 0x46 || buf[offset + 1] !== 0x52) {
                // 'FR'
                offset++;
                continue;
              }
              const row = (buf[offset + 2] << 8) | buf[offset + 3];
              const count = (buf[offset + 4] << 8) | buf[offset + 5];
              const payloadBytes = count * 2;
              if (offset + 6 + payloadBytes + 1 > buf.length) break;

              const payload = buf.slice(offset + 6, offset + 6 + payloadBytes);
              for (let i = 0; i < count && i < W; i++) {
                frameBuf[row * W + i] =
                  (payload[i * 2] << 8) | payload[i * 2 + 1];
              }
              updateCanvas();
              offset += 6 + payloadBytes + 1;
            }
            buf = offset < buf.length ? buf.slice(offset) : new Uint8Array(0);
          }
        }

        // --- KEY CHANGES HERE ---

        connectBtn.onclick = async () => {
          try {
            statusText.innerText = "Requesting port...";
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 921600 });

            writer = port.writable.getWriter();
            reader = port.readable.getReader();

            statusText.innerText = "Connected";
            connectBtn.disabled = true;
            getFrameBtn.disabled = false;

            readLoop(reader).catch((err) => {
              console.error(err);
              statusText.innerText = "Read Error";
            });
          } catch (err) {
            console.error(err);
            statusText.innerText = "Connection Failed";
          }
        };

        getFrameBtn.onclick = () => {
          if (writer) {
            // [0xAA, 0x55, CMD, CHKSUM]
            // For CMD_GET_FRAME (0x01), checksum is 0x01
            writer.write(new Uint8Array([0xaa, 0x55, CMD_GET_FRAME, 0x01]));
          }
        };
      })();
    </script>
  </body>
</html>
