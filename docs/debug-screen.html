<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>ESP32 Screen Viewer</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          sans-serif;
        padding: 12px;
      }
      #canvas {
        image-rendering: pixelated;
        width: 640px;
        height: 480px;
        border: 1px solid #222;
        touch-action: none;
      }
      button {
        margin-right: 6px;
      }
      #status {
        margin-left: 8px;
        color: #555;
      }
    </style>
  </head>
  <body>
    <div>
      <button id="connectBtn">Connect</button>
      <button id="getFrameBtn" disabled>Get Frame</button>
      <span id="status">Disconnected</span>
    </div>
    <canvas id="canvas" width="320" height="240"></canvas>

    <script>
      (async () => {
        const connectBtn = document.getElementById("connectBtn");
        const getFrameBtn = document.getElementById("getFrameBtn");
        const statusEl = document.getElementById("status");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const W = canvas.width,
          H = canvas.height;

        let port = null;
        let writer = null;
        let reader = null;
        let readLoopRunning = false;

        // frame buffer as Uint16 (RGB565)
        const frameBuf = new Uint16Array(W * H);

        // draw buffer (ImageData)
        const imageData = ctx.createImageData(W, H);

        function updateCanvas() {
          // convert frameBuf RGB565 -> RGBA
          for (let i = 0; i < W * H; ++i) {
            const v = frameBuf[i];
            // decode RGB565
            const r = ((v >> 11) & 0x1f) << 3;
            const g = ((v >> 5) & 0x3f) << 2;
            const b = (v & 0x1f) << 3;
            const idx = i * 4;
            imageData.data[idx] = r;
            imageData.data[idx + 1] = g;
            imageData.data[idx + 2] = b;
            imageData.data[idx + 3] = 255;
          }
          ctx.putImageData(imageData, 0, 0);
        }

        // framing helpers
        function cmdGetFrame() {
          // header 0xAA 0x55, cmd 0x01, checksum (cmd)
          const arr = new Uint8Array([0xaa, 0x55, 0x01, 0x01]);
          writer.write(arr);
        }
        function cmdDown(x, y) {
          const xb = [(x >> 8) & 0xff, x & 0xff];
          const yb = [(y >> 8) & 0xff, y & 0xff];
          const cmd = 0x02;
          const payload = [xb[0], xb[1], yb[0], yb[1]];
          let sum = cmd;
          for (const b of payload) sum = (sum + b) & 0xff;
          const arr = new Uint8Array([0xaa, 0x55, cmd, ...payload, sum]);
          writer.write(arr);
        }
        function cmdUp() {
          const cmd = 0x03;
          const arr = new Uint8Array([0xaa, 0x55, cmd, cmd]); // checksum equals cmd
          writer.write(arr);
        }

        // parse incoming stream: look for 'F' 'R' header (0x46 0x52) then read row(2) count(2) payload count*2 checksum(1)
        async function readLoop() {
          readLoopRunning = true;
          const textDecoder = new TextDecoder();
          const readerStream = port.readable.getReader();

          // we use a sliding Uint8 buffer for arbitrary data arrival
          let buf = new Uint8Array(0);

          try {
            while (true) {
              const { value, done } = await readerStream.read();
              if (done) break;
              if (value) {
                // append to buf
                const newBuf = new Uint8Array(buf.length + value.length);
                newBuf.set(buf, 0);
                newBuf.set(value, buf.length);
                buf = newBuf;

                // try to parse any FR frames inside
                let offset = 0;
                while (offset + 6 <= buf.length) {
                  // minimal header + row + count
                  // find 'F' 'R'
                  if (buf[offset] !== 0x46 || buf[offset + 1] !== 0x52) {
                    offset++;
                    continue;
                  }
                  if (offset + 6 > buf.length) break;
                  const row = (buf[offset + 2] << 8) | buf[offset + 3];
                  const count = (buf[offset + 4] << 8) | buf[offset + 5];
                  const payloadBytes = count * 2;
                  const totalLen = 2 + 2 + 2 + payloadBytes + 1; // 'FR' + row(2) + count(2) + payload + checksum
                  if (offset + totalLen > buf.length) break; // wait for more data
                  const payloadStart = offset + 6;
                  const payload = buf.slice(
                    payloadStart,
                    payloadStart + payloadBytes,
                  );
                  const chk = buf[payloadStart + payloadBytes];

                  // compute checksum (sum of header bytes + row bytes + count bytes + payload), mod 256
                  let sum = 0;
                  sum += 0x46;
                  sum += 0x52;
                  sum += buf[offset + 2];
                  sum += buf[offset + 3];
                  sum += buf[offset + 4];
                  sum += buf[offset + 5];
                  for (let i = 0; i < payload.length; ++i)
                    sum = (sum + payload[i]) & 0xff;

                  if (sum === chk) {
                    // write payload into frameBuf at row
                    if (row < H) {
                      // payload is big-endian uint16 per pixel
                      for (let i = 0; i < count && i < W; ++i) {
                        const hi = payload[i * 2];
                        const lo = payload[i * 2 + 1];
                        frameBuf[row * W + i] = (hi << 8) | lo;
                      }
                      // update only the row area on canvas
                      // For simplicity, update entire canvas after chunk
                      updateCanvas();
                    }
                  } else {
                    console.warn("checksum mismatch for chunk", row);
                  }

                  offset += totalLen;
                } // while parsing

                // keep remainder
                if (offset < buf.length) {
                  buf = buf.slice(offset);
                } else {
                  buf = new Uint8Array(0);
                }
              } // if value
            } // while true
          } catch (err) {
            console.error("readloop err", err);
          } finally {
            readerStream.releaseLock();
            readLoopRunning = false;
          }
        }

        async function connect() {
          try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 115200 });
            writer = port.writable.getWriter();
            reader = port.readable.getReader();
            statusEl.textContent = "Connected";
            getFrameBtn.disabled = false;

            // start read loop
            if (!readLoopRunning) {
              readLoop().catch((e) => console.error(e));
            }
          } catch (e) {
            console.error(e);
            statusEl.textContent = "Connection failed";
          }
        }

        connectBtn.onclick = async () => {
          if (!port) {
            await connect();
          } else {
            // disconnect
            try {
              if (writer) {
                writer.releaseLock();
                writer = null;
              }
              if (reader) {
                reader.releaseLock();
                reader = null;
              }
              await port.close();
            } catch (e) {
              console.warn(e);
            }
            port = null;
            statusEl.textContent = "Disconnected";
            getFrameBtn.disabled = true;
          }
        };

        getFrameBtn.onclick = async () => {
          if (!writer) return;
          cmdGetFrame();
        };

        // canvas mouse handlers to send DOWN/UP
        let mouseDown = false;
        function canvasToScreenCoords(evt) {
          const rect = canvas.getBoundingClientRect();
          const cx = evt.clientX - rect.left;
          const cy = evt.clientY - rect.top;
          // scale to 320x240
          const sx = Math.floor(cx * (W / rect.width));
          const sy = Math.floor(cy * (H / rect.height));
          return {
            x: Math.max(0, Math.min(W - 1, sx)),
            y: Math.max(0, Math.min(H - 1, sy)),
          };
        }

        canvas.addEventListener("pointerdown", (e) => {
          if (!writer) return;
          mouseDown = true;
          const p = canvasToScreenCoords(e);
          cmdDown(p.x, p.y);
        });

        canvas.addEventListener("pointermove", (e) => {
          if (!writer || !mouseDown) return;
          const p = canvasToScreenCoords(e);
          // send DOWN repeatedly to emulate movement
          cmdDown(p.x, p.y);
        });

        window.addEventListener("pointerup", (e) => {
          if (!writer || !mouseDown) return;
          mouseDown = false;
          cmdUp();
        });

        // keyboard shortcuts
        window.addEventListener("keydown", (e) => {
          if (e.key === "g") getFrameBtn.click();
        });
      })();
    </script>
  </body>
</html>
