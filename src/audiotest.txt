// Streaming WAV preview to ESP32 DAC (GPIO26) with small static buffers
#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include "driver/dac.h"

#define WIFI_SSID "io"
#define WIFI_PASS "hhhhhh90"
#define WAV_URL "https://manuelwestermeier.github.io/test.wav"

// DAC settings
#define DAC_CHANNEL DAC_CHANNEL_2 // GPIO26

// Small static buffers to avoid large heap allocations
#define RAW_BUF_SIZE 4096         // bytes read from WiFi stream per chunk
#define CIRC_BUF_SIZE 8192        // number of 8-bit samples in circular buffer

// How many bytes of the data chunk we'll preview (you can lower this)
#define MAX_READ_BYTES 102400UL   // 100 KB

// Globals for streaming + ISR
static uint8_t rawBuf[RAW_BUF_SIZE];
static volatile uint8_t circBuf[CIRC_BUF_SIZE];
static volatile uint32_t circHead = 0; // where main thread writes (next free)
static volatile uint32_t circTail = 0; // where ISR reads (next to output)
static volatile bool doneFeeding = false;
static hw_timer_t *timer = nullptr;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

struct WavHeader { char riff[4]; uint32_t size; char wave[4]; };

// little-endian helpers
static inline uint32_t le32(const uint8_t *p){ return (uint32_t)p[0] | ((uint32_t)p[1]<<8) | ((uint32_t)p[2]<<16) | ((uint32_t)p[3]<<24); }
static inline uint16_t le16(const uint8_t *p){ return (uint16_t)p[0] | ((uint16_t)p[1]<<8); }

// Timer ISR: called at sample rate, outputs one 8-bit sample to DAC
IRAM_ATTR void onTimer() {
  uint8_t out = 128; // silence (midpoint)
  portENTER_CRITICAL_ISR(&timerMux);
  if (circTail != circHead) {
    out = circBuf[circTail];
    circTail = (circTail + 1) & (CIRC_BUF_SIZE - 1); // CIRC_BUF_SIZE must be power-of-two
  }
  portEXIT_CRITICAL_ISR(&timerMux);
  dac_output_voltage(DAC_CHANNEL, out);
  // If doneFeeding and buffer emptied, stop timer (safe to disable here)
  if (doneFeeding) {
    portENTER_CRITICAL_ISR(&timerMux);
    bool empty = (circTail == circHead);
    portEXIT_CRITICAL_ISR(&timerMux);
    if (empty) {
      timerAlarmDisable(timer);
    }
  }
}

void setupTimer(uint32_t sampleRate) {
  // prescaler 80 -> 1 tick = 1 microsecond on 80MHz APB
  timer = timerBegin(0, 80, true);
  timerAttachInterrupt(timer, &onTimer, true);
  uint32_t period_us = (uint32_t)(1000000.0 / (double)sampleRate + 0.5);
  if (period_us < 1) period_us = 1;
  timerAlarmWrite(timer, period_us, true);
}

void setup() {
  Serial.begin(115200);
  delay(50);

  // sanity: CIRC_BUF_SIZE must be a power of two for bitmask wrap
  if ((CIRC_BUF_SIZE & (CIRC_BUF_SIZE - 1)) != 0) {
    Serial.println("CIRC_BUF_SIZE must be power of two!");
    while (1) delay(1000);
  }

  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi...");
  while (WiFi.status() != WL_CONNECTED) { delay(300); Serial.print("."); }
  Serial.println(" OK");

  HTTPClient http;
  http.begin(WAV_URL);
  int httpCode = http.GET();
  if (httpCode != HTTP_CODE_OK) {
    Serial.printf("HTTP error: %d\n", httpCode);
    http.end();
    return;
  }

  WiFiClient *stream = http.getStreamPtr();

  // Read RIFF header
  WavHeader wh;
  if (stream->readBytes((char*)&wh, sizeof(wh)) != (int)sizeof(wh)) {
    Serial.println("Failed to read RIFF header");
    http.end();
    return;
  }
  if (memcmp(wh.riff, "RIFF", 4) != 0 || memcmp(wh.wave, "WAVE", 4) != 0) {
    Serial.println("Not a WAV file");
    http.end();
    return;
  }

  // parse chunks for "fmt " and "data"
  uint16_t audioFormat = 0, numChannels = 0, bitsPerSample = 0;
  uint32_t sampleRate = 0, dataChunkSize = 0;
  while (stream->connected() && stream->available()) {
    uint8_t hdr[8];
    if (stream->readBytes((char*)hdr, 8) != 8) {
      Serial.println("Failed reading chunk header");
      break;
    }
    uint32_t chunkSize = le32(hdr + 4);
    if (memcmp(hdr, "fmt ", 4) == 0) {
      // read fmt chunk (small)
      if (chunkSize > RAW_BUF_SIZE) {
        // temporary allocate on stack won't work; read in parts
        uint8_t *fmt = (uint8_t*)malloc(chunkSize);
        if (!fmt) { Serial.println("fmt malloc fail"); http.end(); return; }
        if (stream->readBytes((char*)fmt, chunkSize) != (int)chunkSize) { free(fmt); Serial.println("fmt read fail"); http.end(); return; }
        audioFormat = le16(fmt + 0);
        numChannels = le16(fmt + 2);
        sampleRate = le32(fmt + 4);
        bitsPerSample = le16(fmt + 14);
        free(fmt);
      } else {
        if (stream->readBytes((char*)rawBuf, chunkSize) != (int)chunkSize) { Serial.println("fmt read fail"); http.end(); return; }
        audioFormat = le16(rawBuf + 0);
        numChannels = le16(rawBuf + 2);
        sampleRate = le32(rawBuf + 4);
        bitsPerSample = le16(rawBuf + 14);
      }
      Serial.printf("fmt: audioFormat=%u channels=%u sampleRate=%u bits=%u\n", audioFormat, numChannels, sampleRate, bitsPerSample);
    } else if (memcmp(hdr, "data", 4) == 0) {
      dataChunkSize = chunkSize;
      Serial.printf("Found data chunk size=%u bytes\n", dataChunkSize);
      break;
    } else {
      // skip chunk
      uint32_t toSkip = chunkSize;
      while (toSkip > 0) {
        uint32_t r = (toSkip > RAW_BUF_SIZE) ? RAW_BUF_SIZE : toSkip;
        int got = stream->readBytes((char*)rawBuf, r);
        if (got <= 0) { Serial.println("skip read fail"); break; }
        toSkip -= got;
      }
    }
  }

  if (dataChunkSize == 0) { Serial.println("No data chunk"); http.end(); return; }
  Serial.printf("Will preview up to %u bytes (max=%u)\n", (unsigned)min((uint32_t)MAX_READ_BYTES, dataChunkSize), (unsigned)MAX_READ_BYTES);

  // initialize DAC and timer
  dac_output_enable(DAC_CHANNEL);
  setupTimer(sampleRate);
  // start timer (will output silence until data provided)
  timerAlarmEnable(timer);

  // start streaming & converting (main thread)
  uint32_t toRead = dataChunkSize;
  if (toRead > MAX_READ_BYTES) toRead = MAX_READ_BYTES;
  uint32_t readTotal = 0;

  // conversion helpers
  auto circFree = []() -> uint32_t {
    uint32_t h = circHead;
    uint32_t t = circTail;
    if (h >= t) return CIRC_BUF_SIZE - (h - t) - 1;
    return (t - h) - 1;
  };

  // main fill loop: read raw chunks, convert to 8-bit samples, put into circular buffer
  while (readTotal < toRead) {
    int want = (int)min((uint32_t)RAW_BUF_SIZE, toRead - readTotal);
    int got = stream->readBytes((char*)rawBuf, want);
    if (got <= 0) { Serial.println("stream ended early"); break; }
    readTotal += got;

    // convert rawBuf[0..got-1] to 8-bit unsigned samples and push to circBuf
    if (bitsPerSample == 16) {
      // 16-bit samples are little-endian signed
      int sampleCount = got / 2; // number of 16-bit samples (may be mono or interleaved stereo)
      int idx = 0;
      while (idx < sampleCount) {
        // ensure there is room in circular buffer
        while (circFree() < 1) { delay(1); } // wait for ISR to consume
        uint8_t outSample;
        if (numChannels == 1) {
          int16_t s = (int16_t)le16(&rawBuf[idx * 2]);
          outSample = (uint8_t)(((uint16_t)(s + 32768)) >> 8);
          idx += 1;
        } else {
          // stereo: average L and R
          if (idx + 1 >= sampleCount) break; // incomplete pair
          int16_t l = (int16_t)le16(&rawBuf[(idx + 0) * 2]);
          int16_t r = (int16_t)le16(&rawBuf[(idx + 1) * 2]);
          int32_t mix = ((int32_t)l + (int32_t)r) / 2;
          outSample = (uint8_t)(((uint16_t)(mix + 32768)) >> 8);
          idx += 2;
        }
        // write into circ buffer atomically
        portENTER_CRITICAL(&timerMux);
        circBuf[circHead] = outSample;
        circHead = (circHead + 1) & (CIRC_BUF_SIZE - 1);
        portEXIT_CRITICAL(&timerMux);
      }
    } else if (bitsPerSample == 8) {
      // 8-bit unsigned samples
      int sampleCount = got; // each byte is a sample (mono or interleaved)
      int idx = 0;
      if (numChannels == 1) {
        while (idx < sampleCount) {
          while (circFree() < 1) { delay(1); }
          uint8_t v = rawBuf[idx++];
          portENTER_CRITICAL(&timerMux);
          circBuf[circHead] = v;
          circHead = (circHead + 1) & (CIRC_BUF_SIZE - 1);
          portEXIT_CRITICAL(&timerMux);
        }
      } else {
        while (idx + 1 < sampleCount) {
          while (circFree() < 1) { delay(1); }
          uint8_t a = rawBuf[idx++];
          uint8_t b = rawBuf[idx++];
          uint8_t v = (uint8_t)(((uint16_t)a + (uint16_t)b) >> 1);
          portENTER_CRITICAL(&timerMux);
          circBuf[circHead] = v;
          circHead = (circHead + 1) & (CIRC_BUF_SIZE - 1);
          portEXIT_CRITICAL(&timerMux);
        }
      }
    } else {
      Serial.println("Unsupported bitsPerSample");
      break;
    }

    // progress print
    static unsigned long lastPrint = 0;
    if (millis() - lastPrint > 500) {
      lastPrint = millis();
      uint32_t h = circHead, t = circTail;
      uint32_t buffered = (h >= t) ? (h - t) : (CIRC_BUF_SIZE - (t - h));
      Serial.printf("downloaded %u/%u bytes, circ buffered=%u\n", (unsigned)readTotal, (unsigned)toRead, (unsigned)buffered);
    }
  } // end read loop

  // finished feeding requested bytes
  doneFeeding = true;
  Serial.println("Finished feeding subset â€” waiting for buffer to drain...");

  // wait for ISR to drain the buffer (timeout to avoid infinite loop)
  unsigned long start = millis();
  while (true) {
    portENTER_CRITICAL(&timerMux);
    bool empty = (circTail == circHead);
    portEXIT_CRITICAL(&timerMux);
    if (empty) break;
    if (millis() - start > 15000) { Serial.println("Timeout waiting for buffer to drain"); break; }
    delay(20);
  }

  Serial.println("Playback (preview) complete.");
  // cleanup
  timerAlarmDisable(timer);
  timerDetachInterrupt(timer);
  timerEnd(timer);
  timer = nullptr;
  dac_output_disable(DAC_CHANNEL);
  http.end();
}

void loop() {
  // nothing
}
